<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Vision Interattivo Dinamico</title>
    <style>
        :root {
            --main-bg-color: #000;
            --main-accent-color: #7cfc00;
            --header-border-color: #fff;
            --button-text-color: #fff;
            --button-border-color: #fff;
            --button-hover-bg-color: #333;
            --slider-thumb-color: #7cfc00;
            --slider-track-color: #fff;
            --paragraph-text-color: #000; 
            --image-sub-text-color: #000; 
            --kernel-matrix-text-color: #000; 
            --kernel-matrix-bg-color: #2a2a2a; 
            --general-text-color: #f0fff0; 
        }

        html { box-sizing: border-box; overflow-x: hidden; }
        *, *::before, *::after { box-sizing: inherit; }
        body {
            margin: 0; padding: 0; background-color: var(--main-bg-color); color: var(--general-text-color);
            font-family: Helvetica, sans-serif; padding-top: 70px;
        }
        .site-header {
            position: fixed; top: 0; left: 0; width: 100%; background-color: var(--main-bg-color);
            z-index: 1000; padding: 10px 20px; display: flex;
            justify-content: space-between; align-items: center;
        }
        .site-header.with-border { border-bottom: 1px solid var(--header-border-color); }
        .site-header h1 {
            font-size: 1.8em; font-weight: bold; color: var(--main-accent-color); margin: 0; display: none;
            cursor: pointer; user-select: none;
        }
        #change-image-controls { display: none; }
        #change-image-button {
            color: var(--button-text-color); font-size: 0.9em; cursor: pointer; text-transform: uppercase;
            font-weight: bold; padding: 8px 12px; background-color: transparent;
            border: 1px solid var(--button-border-color); border-radius: 4px;
        }
        #change-image-button:hover { background-color: var(--button-hover-bg-color); }
        #initial-upload-prompt {
            font-size: 2.5em; font-weight: bold; color: #fff; text-align: center;
            cursor: pointer; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); z-index: 900; display: block;
        }
        .hidden-file-input { display: none; }
        #main-content-wrapper { display: none; }

        .content-block {
            max-width: 960px; 
            margin-left: 20px; 
            margin-right: 20px;
            padding-top: 20px;
            padding-bottom: 0;
        }

        #uploaded-image-section {
            display: flex;
            align-items: flex-start; 
            gap: 20px; 
        }
        #image-column { /* Contiene immagine e suo testo */ }

        #main-image-display-wrapper {
            position: relative; 
            display: inline-block; 
            max-width:100%;
            line-height: 0;
        }
        #main-image-display-wrapper canvas#main-display-canvas,
        #main-image-display-wrapper canvas#uploaded-image-numeric-overlay {
            max-width: 100%; height: auto; display: block;
        }
        #uploaded-image-numeric-overlay{
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; background-color: var(--main-bg-color);
        }

        #fixed-zoom-canvas {
            display: block;
            border: 1px solid var(--main-accent-color); 
        }
        
        .technique-entry { padding-bottom: 20px; }
        .content-block h2 {
            font-size: 1.8em; color: var(--main-accent-color); font-weight: bold; margin-top: 0; margin-bottom: 15px;
        }
        .content-block p { color: var(--paragraph-text-color); margin-bottom: 15px; line-height: 1.6; }
        .content-block ul { color: var(--paragraph-text-color); margin-bottom: 15px; line-height: 1.6; padding-left: 20px;}
        .content-block li { margin-bottom: 8px; }

        .image-sub-text { font-size: 8pt; color: var(--image-sub-text-color); text-align: center; margin-top:5px; margin-bottom: 15px;}
        #uploaded-image-section .image-sub-text { text-align: left;} 
        
        #grayscale-canvas, #sobel-canvas, #optical-flow-canvas,
        #lowe-features-canvas, #lowe-recognition-canvas,
        #objdetect-grayscale-canvas, #objdetect-binary-canvas, #objdetect-result-canvas,
        #segmentation-original-canvas, #segmentation-result-canvas,
        #cnn-input-patch-canvas, .feature-map-output-canvas, .kernel-viz-canvas,
        #number-recognition-section canvas 
        {
            max-width: 100%; height: auto; display: block;
            border: 1px solid #444; margin-bottom: 8pt; background-color: #111;
        }
        
        .image-container, 
        .canvas-item,
        .cnn-feature-map-item
        {
            flex: 1; 
            min-width: 0; 
            display: flex; 
            flex-direction: column; 
            align-items: center;
        }

        .sobel-demonstration .image-comparison-container { 
            display: flex; gap: 15px; align-items: flex-start; margin-bottom: 15px;
        }

        .sobel-slider-wrapper {
            position: relative; width: 200px; margin-top: 15px; margin-bottom: 10px;
        }
        .sobel-slider-label {
            position: absolute; right: 100%; top: 50%; transform: translateY(-50%);
            margin-right: 10px; font-size: 0.9em; font-weight: bold;
            color: var(--main-accent-color); white-space: nowrap;
        }
        .styled-slider-input { -webkit-appearance: none; appearance: none; width: 100%; height: 22px; background: transparent; cursor: pointer; display: block; margin: 0; }
        .styled-slider-input::-webkit-slider-runnable-track { width: 100%; height: 8px; background: var(--slider-track-color); border-radius: 0px; border: none; }
        .styled-slider-input::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: var(--slider-thumb-color); border-radius: 0px; border: none; margin-top: -6px; }
        .styled-slider-input::-moz-range-track { width: 100%; height: 8px; background: var(--slider-track-color); border-radius: 0px; border: none; }
        .styled-slider-input::-moz-range-thumb { width: 20px; height: 20px; background: var(--slider-thumb-color); border-radius: 0px; border: none; }

        #object-recognition-ml-section .multi-canvas-demo-container,
        #image-segmentation-section .multi-canvas-demo-container 
        { 
            display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-start; margin-bottom: 10px; 
            justify-content: flex-start; 
        }
        #object-recognition-ml-section #binary-slider-wrapper,
        #image-segmentation-section #kmeans-slider-wrapper 
        {
             margin-top: 15px; 
             margin-left: 0; 
        }
        
        .cnn-demo-container { margin-top: 15px; }
        .cnn-input-area { display: flex; flex-direction: column; align-items: center; margin-bottom: 20px; }
        .cnn-feature-maps-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; }
        .kernel-visualization-wrapper { display: flex; flex-direction: column; align-items: center; }
        .kernel-visualization-wrapper .image-sub-text { margin-bottom: 3px; }
        .kernel-viz-canvas { width: 60px; height: 60px; border: 1px solid #666 !important; margin-bottom: 5px !important; }
        .kernel-matrix-text { font-family: monospace; font-size: 0.75em; white-space: pre; background-color: var(--kernel-matrix-bg-color); padding: 5px; border: 1px solid #444; color: var(--kernel-matrix-text-color); border-radius: 3px; text-align: center; line-height: 1.1; margin-top: 3px; min-height: 3.5em; }
        .cnn-feature-map-item .image-sub-text { font-size: 7pt; }

        .sobel-section-block { padding-bottom: 15px; }
        .sobel-section-block + .full-bleed-separator { margin-top: 20px; }
        .full-bleed-separator { width: 100vw; margin-left: calc(50% - 50vw); height: 1px; background-color: var(--header-border-color); margin-top: 40px; margin-bottom: 40px; }
        .demo-separator-within-section { border: none; height: 1px; background-color: #555; margin-top: 30px; margin-bottom: 20px; }
        #credits-info { position: fixed; bottom: 20px; right: 20px; color: var(--main-accent-color); font-size: 0.9em; font-weight: bold; text-align: right; line-height: 1.3; z-index: 1000; display: none; }
        #sketch-container { display: flex; flex-direction: column; align-items: flex-start; margin-top: 20px; margin-bottom: 20px; }
        #sketch-buttons-container { display: flex; gap: 15px; margin-top: 15px; margin-bottom: 15px; }
        .sketch-button { color: var(--button-text-color); font-size: 0.9em; cursor: pointer; text-transform: uppercase; font-weight: bold; padding: 8px 12px; background-color: transparent; border: 1px solid var(--button-border-color); border-radius: 4px; }
        .sketch-button:hover { background-color: var(--button-hover-bg-color); }
        #sketch-result-text { color: var(--main-accent-color); font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>

    <header class="site-header">
        <h1>Computer Vision</h1>
        <div id="change-image-controls">
            <button id="change-image-button">CAMBIA IMMAGINE</button>
            <input type="file" id="secondary-file-input" class="hidden-file-input" accept="image/*">
        </div>
    </header>

    <div id="initial-upload-prompt">Upload image</div>
    <input type="file" id="primary-file-input" class="hidden-file-input" accept="image/*">

    <div id="main-content-wrapper">
        <div class="content-block" id="uploaded-image-section">
            <div id="image-column">
                <div id="main-image-display-wrapper">
                    <canvas id="main-display-canvas"></canvas>
                    <canvas id="uploaded-image-numeric-overlay"></canvas>
                </div>
                <p class="image-sub-text" id="main-image-sub-text">Immagine caricata dall'utente. Passa il mouse sull'immagine per vedere i dettagli dei pixel.</p>
            </div>
            <canvas id="fixed-zoom-canvas"></canvas> 
        </div>

        <div class="full-bleed-separator"></div>
        <div class="content-block technique-entry sobel-section-block" data-demo-type="sobel">
            <h2>Primi Tentativi e Riconoscimento di Forme (Anni '60-'70)</h2>
            <p>I primi approcci si concentravano sull'analisi di forme semplici e immagini binarie. L'estrazione dei bordi, come con l'algoritmo di Sobel, era cruciale. Il processo: Immagine -> Scala di Grigi -> Calcolo Gradiente -> Bordi.</p>
            <div class="sobel-demonstration">
                <div class="image-comparison-container">
                    <div class="image-container" id="grayscale-image-wrapper">
                        <canvas id="grayscale-canvas"></canvas>
                        <p class="image-sub-text">1. Immagine in Scala di Grigi</p>
                    </div>
                    <div class="image-container" id="sobel-image-wrapper">
                        <canvas id="sobel-canvas"></canvas>
                        <p class="image-sub-text">2. Bordi Rilevati (Sobel)</p>
                        <div class="sobel-slider-wrapper">
                            <label for="sobel-threshold-slider" class="sobel-slider-label">K (Soglia):&nbsp;<span id="threshold-value-display">100</span></label>
                            <input type="range" id="sobel-threshold-slider" class="styled-slider-input" min="0" max="255" value="100">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="full-bleed-separator"></div>
        <div class="content-block technique-entry" id="object-recognition-ml-section" data-demo-type="object-recognition">
            <h2>Riconoscimento di Oggetti e Machine Learning (Anni '90-'2000)</h2>
            <p>L'apprendimento automatico ha introdotto metodi per "addestrare" i computer a riconoscere oggetti. Un approccio basilare è il rilevamento di regioni connesse (blob) dopo aver semplificato l'immagine (es. binarizzazione). Processo: Immagine Originale -> Scala di Grigi -> Binarizzazione (soglia K) -> Rilevamento Blob e Bounding Box sull'originale.</p>

            <div class="multi-canvas-demo-container">
                <div class="canvas-item">
                    <canvas id="objdetect-grayscale-canvas"></canvas>
                    <p class="image-sub-text">1. Scala di Grigi</p>
                </div>
                <div class="canvas-item">
                    <canvas id="objdetect-binary-canvas"></canvas>
                    <p class="image-sub-text">2. Immagine Binarizzata (Soglia K)</p>
                </div>
                <div class="canvas-item">
                    <canvas id="objdetect-result-canvas"></canvas>
                    <p class="image-sub-text">3. Rilevamento Blob (sull'originale)</p>
                </div>
            </div>
            <div class="sobel-slider-wrapper" id="binary-slider-wrapper" style="margin-left:0;">
                <label for="binary-threshold-slider" class="sobel-slider-label">K Binarizz.:&nbsp;<span id="binary-threshold-value-display">128</span></label>
                <input type="range" id="binary-threshold-slider" class="styled-slider-input" min="0" max="255" value="128">
            </div>
        </div>

        <div class="full-bleed-separator"></div>

        <div class="content-block technique-entry" id="image-segmentation-section" data-demo-type="segmentation">
            <h2>Segmentazione delle Immagini: Dividere per Comprendere</h2>
            <p>La <strong>segmentazione delle immagini</strong> è un processo fondamentale nella computer vision che consiste nel suddividere un'immagine digitale in più regioni o segmenti (insiemi di pixel). L'obiettivo è semplificare o cambiare la rappresentazione di un'immagine in qualcosa di più significativo e facile da analizzare. Ogni pixel in una regione condivide alcune caratteristiche comuni, come il colore, l'intensità o la texture.</p>
            <p>Esistono diversi tipi di segmentazione:</p>
            <ul>
                <li><strong>Segmentazione Semantica:</strong> Assegna a ogni pixel dell'immagine una etichetta di classe (es. "strada", "auto", "persona", "cielo"). Tutti i pixel appartenenti alla stessa classe ricevono la stessa etichetta.</li>
                <li><strong>Segmentazione Istanza:</strong> Simile alla semantica, ma distingue le diverse istanze di oggetti della stessa classe (es. "auto 1", "auto 2", "persona A", "persona B").</li>
                <li><strong>Segmentazione Panottica:</strong> Combina la segmentazione semantica e quella istanza, fornendo sia l'etichetta di classe che l'identificatore di istanza per ogni pixel.</li>
            </ul>
            <p>Di seguito, una dimostrazione semplificata di segmentazione basata sul raggruppamento dei colori (clustering) utilizzando un approccio simile all'algoritmo K-Means. L'immagine viene processata per ridurre il numero di colori distinti, creando regioni basate sulla similarità cromatica. <strong>Nota:</strong> l'applicazione di K-Means all'intera immagine potrebbe richiedere alcuni secondi, specialmente per immagini di grandi dimensioni.</p>
            
            <div class="segmentation-demonstration" style="display: flex; flex-direction: column; align-items: flex-start;">
                <div class="multi-canvas-demo-container" id="segmentation-canvases">
                    <div class="canvas-item">
                        <canvas id="segmentation-original-canvas"></canvas>
                        <p class="image-sub-text">1. Immagine Originale</p>
                    </div>
                    <div class="canvas-item">
                        <canvas id="segmentation-result-canvas"></canvas>
                        <p class="image-sub-text">2. Segmentata per Colore (K-Means)</p>
                    </div>
                </div>
                <div class="sobel-slider-wrapper" id="kmeans-slider-wrapper" style="width: 250px; margin-left:0;">
                    <label for="kmeans-k-slider" class="sobel-slider-label">Numero Segmenti (K):&nbsp;<span id="kmeans-k-value-display">3</span></label>
                    <input type="range" id="kmeans-k-slider" class="styled-slider-input" min="2" max="10" value="3">
                </div>
                 <button id="run-segmentation-button" class="sketch-button" style="margin-top:15px;">Avvia Segmentazione K-Means</button>
            </div>
        </div>

        <div class="full-bleed-separator"></div>
        <div class="content-block technique-entry" id="number-recognition-section" data-demo-type="number-recognition">
            <h2>Riconoscimento rudimentale da 1 a 3</h2>
            <p>Un esempio semplice di riconoscimento di pattern è il riconoscimento di cifre scritte a mano. Questo esempio mostra un approccio rudimentale per riconoscere i numeri da 1 a 3 basato su caratteristiche geometriche come proporzioni e distribuzione dei punti.</p>
            
            <div id="sketch-container"></div>
            <div id="sketch-buttons-container"></div>
            <div id="sketch-result-text"></div>
            
            <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
            <script>
                // p5.js sketch
                (function() {
                    let sketchP5Canvas, drawingPoints = [], isDrawing = false, resultText = "Disegna un numero da 1 a 3";
                    let clearButton, recognizeButton, resultTextElement, p5Instance;
                    const sketch = (p) => {
                        p.setup = function() {
                            sketchP5Canvas = p.createCanvas(300, 300).parent(p.select('#sketch-container'));
                            p.background(255);
                            clearButton = p.createButton('CANCELLA').parent(p.select('#sketch-buttons-container')).class('sketch-button').mousePressed(() => { p.background(255); drawingPoints = []; resultText = "Disegna un numero da 1 a 3"; resultTextElement.html(resultText); });
                            recognizeButton = p.createButton('RICONOSCI').parent(p.select('#sketch-buttons-container')).class('sketch-button').mousePressed(() => {
                                if (drawingPoints.length === 0) { resultTextElement.html("Disegna prima un numero!"); return; }
                                let minX = p.width, maxX = 0, minY = p.height, maxY = 0;
                                drawingPoints.forEach(pt => { minX = p.min(minX, pt.x); maxX = p.max(maxX, pt.x); minY = p.min(minY, pt.y); maxY = p.max(maxY, pt.y); });
                                let boxW = maxX-minX, boxH = maxY-minY, cX = (minX+maxX)/2, lT = p.width/3, rTT = 2*p.width/3;
                                let lC=0,mC=0,rC=0; drawingPoints.forEach(pt => { if(pt.x<lT)lC++; else if(pt.x<rTT)mC++; else rC++; });
                                let aspRat = boxH/boxW;
                                if(aspRat > 1.5 && mC > lC && cX > p.width/3) resultText = "Hai disegnato un 1!";
                                else if(aspRat < 1.5 && lC > 0 && rC > 0 && boxW > p.width/4 && boxH > p.height/4) resultText = "Hai disegnato un 2!";
                                else if(rC > lC && mC > lC && boxW < boxH && boxW > p.width/6) resultText = "Hai disegnato un 3!";
                                else resultText = "Non riconosco. Riprova!";
                                resultTextElement.html(resultText);
                            });
                            resultTextElement = p.select('#sketch-result-text').html(resultText);
                        };
                        p.draw = function() { if (isDrawing && drawingPoints.length > 1) { let prev = drawingPoints[drawingPoints.length-2], curr = drawingPoints[drawingPoints.length-1]; p.stroke(0); p.strokeWeight(10); p.line(prev.x, prev.y, curr.x, curr.y); }};
                        p.mousePressed = function() { if (p.mouseX>=0 && p.mouseX<=p.width && p.mouseY>=0 && p.mouseY<=p.height) { isDrawing = true; drawingPoints.push({x:p.mouseX, y:p.mouseY}); return false; }};
                        p.mouseDragged = function() { if (isDrawing && p.mouseX>=0 && p.mouseX<=p.width && p.mouseY>=0 && p.mouseY<=p.height) { drawingPoints.push({x:p.mouseX, y:p.mouseY}); return false; }};
                        p.mouseReleased = function() { if (isDrawing) { isDrawing = false; return false; }};
                    };
                    document.addEventListener('DOMContentLoaded', () => { if (document.getElementById('sketch-container')) { p5Instance = new p5(sketch); }});
                })();
            </script>
        </div>
    </div>

    <div id="credits-info">
        ISIA U<br>
        Elia Miodini<br>
        Aiudi Francesco
    </div>

    <script>
        // --- VARIABILI DOM GLOBALI ---
        const siteHeader = document.querySelector('.site-header');
        const headerTitle = siteHeader ? siteHeader.querySelector('h1') : null;
        const changeImageControls = document.getElementById('change-image-controls');
        const changeImageButton = document.getElementById('change-image-button');
        const secondaryFileInput = document.getElementById('secondary-file-input');
        const initialUploadPrompt = document.getElementById('initial-upload-prompt');
        const primaryFileInput = document.getElementById('primary-file-input');
        const mainContentWrapper = document.getElementById('main-content-wrapper');
        const mainDisplayCanvas = document.getElementById('main-display-canvas');
        const uploadedImageNumericOverlay = document.getElementById('uploaded-image-numeric-overlay');
        const mainImageSubText = document.getElementById('main-image-sub-text');
        const creditsInfo = document.getElementById('credits-info');
        const grayscaleCanvas = document.getElementById('grayscale-canvas');
        const sobelCanvas = document.getElementById('sobel-canvas');
        const sobelThresholdSlider = document.getElementById('sobel-threshold-slider');
        const thresholdValueDisplay = document.getElementById('threshold-value-display');
        let grayscaleImageDataForSobel = null;
        let gradientMagnitudeData = null;
        const opticalFlowCanvas = document.getElementById('optical-flow-canvas'); 
        const loweFeaturesCanvas = document.getElementById('lowe-features-canvas');
        const loweRecognitionCanvas = document.getElementById('lowe-recognition-canvas');
        let loweCubeAnimationId = null, loweCubeCurrentAngleY = 0, sumXGlobalLowe = 0, sumYGlobalLowe = 0, edgePixelsCountGlobalLowe = 0;
        const objdetectGrayscaleCanvas = document.getElementById('objdetect-grayscale-canvas');
        const objdetectBinaryCanvas = document.getElementById('objdetect-binary-canvas');
        const objdetectResultCanvas = document.getElementById('objdetect-result-canvas');
        const binaryThresholdSlider = document.getElementById('binary-threshold-slider');
        const binaryThresholdValueDisplay = document.getElementById('binary-threshold-value-display');
        
        const cnnInputPatchCanvas = document.getElementById('cnn-input-patch-canvas'); 
        const featureMapOutputCanvases = [ ]; 
        const kernelVizCanvases = [ ]; 
        const kernelMatrixTexts = [ ]; 
        const featureMapSubtexts = [ ]; 

        const segmentationOriginalCanvas = document.getElementById('segmentation-original-canvas');
        const segmentationResultCanvas = document.getElementById('segmentation-result-canvas');
        const kmeansKSlider = document.getElementById('kmeans-k-slider');
        const kmeansKValueDisplay = document.getElementById('kmeans-k-value-display');
        const runSegmentationButton = document.getElementById('run-segmentation-button');
        let kmeansWorker = null;

        let currentUploadedImage = null, demoObserver = null, demoRenderFlags = {}, isNumericViewActive = false;
        const numericViewBlockSize = 16;
        const pixelCanvas = document.createElement('canvas');
        const pixelCtx = pixelCanvas.getContext('2d');
        if (!pixelCtx) console.error("Impossibile creare context 2D per pixelCanvas.");

        const fixedZoomCanvas = document.getElementById('fixed-zoom-canvas');

        let p5StyleMagnifier = {
            zoomBoxSize: 140, 
            isInitialized: false, lastMouseX: -1, lastMouseY: -1,
            normalZoomFactor: 20, normalMatrixSize: 7, 
        };

        function setupFixedMagnifier() {
            if (!fixedZoomCanvas) { console.error("Canvas lente fissa non trovato."); return; }
            if (p5StyleMagnifier.normalMatrixSize % 2 === 0) p5StyleMagnifier.normalMatrixSize++;
            
            p5StyleMagnifier.zoomBoxSize = p5StyleMagnifier.normalMatrixSize * p5StyleMagnifier.normalZoomFactor;
            fixedZoomCanvas.width = p5StyleMagnifier.zoomBoxSize;
            fixedZoomCanvas.height = p5StyleMagnifier.zoomBoxSize;

            const zoomCtx = fixedZoomCanvas.getContext('2d');
            if (!zoomCtx) { console.error("Impossibile ottenere il context per fixed-zoom-canvas"); return; }
            zoomCtx.clearRect(0, 0, fixedZoomCanvas.width, fixedZoomCanvas.height); 
            zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color') || '#7cfc00';
            zoomCtx.textAlign = 'center'; zoomCtx.textBaseline = 'middle';
            const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12));
            zoomCtx.font = `bold ${fontSize}px Arial`;
            wrapText(zoomCtx, "Muovi il mouse sull'immagine", fixedZoomCanvas.width / 2, fixedZoomCanvas.height / 2, fixedZoomCanvas.width - 10, fontSize * 1.2);
            p5StyleMagnifier.isInitialized = true;
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' '); let line = ''; let lines = [];
            for(let n = 0; n < words.length; n++) { const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine); if (metrics.width > maxWidth && n > 0) { lines.push(line.trim()); line = words[n] + ' '; } else { line = testLine; }}
            lines.push(line.trim()); let startY = y - ((lines.length -1) * lineHeight / 2); lines.forEach((l, i) => { context.fillText(l, x, startY + (i * lineHeight)); });
        }

        function updateFixedMagnifier(event) {
            if (!p5StyleMagnifier.isInitialized || !currentUploadedImage || !currentUploadedImage.complete || currentUploadedImage.naturalWidth === 0 || !fixedZoomCanvas || !pixelCtx) return;
            const mainCanvasRect = mainDisplayCanvas.getBoundingClientRect(); if (mainCanvasRect.width === 0 || mainCanvasRect.height === 0) return;
            const scaleX = mainDisplayCanvas.width / mainCanvasRect.width, scaleY = mainDisplayCanvas.height / mainCanvasRect.height;
            const mouseXonCanvas = Math.floor((event.clientX - mainCanvasRect.left) * scaleX), mouseYonCanvas = Math.floor((event.clientY - mainCanvasRect.top) * scaleY);
            p5StyleMagnifier.lastMouseX = mouseXonCanvas; p5StyleMagnifier.lastMouseY = mouseYonCanvas;
            const zoomCtx = fixedZoomCanvas.getContext('2d'); if (!zoomCtx) return;

            const currentMatrixSize = p5StyleMagnifier.normalMatrixSize;
            const currentZoomFactor = p5StyleMagnifier.normalZoomFactor; 
            
            zoomCtx.clearRect(0, 0, zoomCtx.canvas.width, zoomCtx.canvas.height);

            if (mouseXonCanvas >= 0 && mouseXonCanvas < mainDisplayCanvas.width && mouseYonCanvas >= 0 && mouseYonCanvas < mainDisplayCanvas.height) {
                const offset = Math.floor(currentMatrixSize / 2);

                for (let i = 0; i < currentMatrixSize; i++) { 
                    for (let j = 0; j < currentMatrixSize; j++) {
                        const zoomedCellX = j * currentZoomFactor; 
                        const zoomedCellY = i * currentZoomFactor;

                        const imgX = mouseXonCanvas + (j - offset);
                        const imgY = mouseYonCanvas + (i - offset);

                        if (imgX >= 0 && imgX < pixelCanvas.width && imgY >= 0 && imgY < pixelCanvas.height) {
                            const pixelData = pixelCtx.getImageData(imgX, imgY, 1, 1).data; 

                            if (isNumericViewActive) {
                                const valR = pixelData[0]; const valG = pixelData[1]; const valB = pixelData[2];
                                const fontSize = Math.max(6, Math.floor(currentZoomFactor / 3.8)); 
                                zoomCtx.font = `${fontSize}px monospace`;
                                zoomCtx.textAlign = 'center'; zoomCtx.textBaseline = 'middle';
                                const textLineHeight = fontSize * 1.05; 

                                const textYBase = zoomedCellY + currentZoomFactor / 2;
                                zoomCtx.fillStyle = 'rgb(255,80,80)'; 
                                zoomCtx.fillText(valR.toString().padStart(3,' '), zoomedCellX + currentZoomFactor / 2, textYBase - textLineHeight);
                                zoomCtx.fillStyle = 'rgb(80,255,80)'; 
                                zoomCtx.fillText(valG.toString().padStart(3,' '), zoomedCellX + currentZoomFactor / 2, textYBase);
                                zoomCtx.fillStyle = 'rgb(80,80,255)'; 
                                zoomCtx.fillText(valB.toString().padStart(3,' '), zoomedCellX + currentZoomFactor / 2, textYBase + textLineHeight);
                                
                                zoomCtx.strokeStyle = (i === offset && j === offset) ? 'yellow' : 'rgba(180, 180, 180, 0.3)';
                                zoomCtx.lineWidth = (i === offset && j === offset) ? 1.5 : 0.5;
                                zoomCtx.strokeRect(zoomedCellX, zoomedCellY, currentZoomFactor, currentZoomFactor);

                            } else { 
                                zoomCtx.fillStyle = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                                zoomCtx.fillRect(zoomedCellX, zoomedCellY, currentZoomFactor, currentZoomFactor);
                                zoomCtx.strokeStyle = (i === offset && j === offset) ? 'red' : 'rgba(200, 200, 200, 0.3)';
                                zoomCtx.lineWidth = (i === offset && j === offset) ? 2 : 0.5;
                                zoomCtx.strokeRect(zoomedCellX, zoomedCellY, currentZoomFactor, currentZoomFactor);
                            }
                        } else { 
                            zoomCtx.fillStyle = 'rgba(60, 60, 60, 0.7)'; 
                            zoomCtx.fillRect(zoomedCellX, zoomedCellY, currentZoomFactor, currentZoomFactor);
                            zoomCtx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
                            zoomCtx.strokeRect(zoomedCellX, zoomedCellY, currentZoomFactor, currentZoomFactor);
                        }
                    }
                }
            } else { 
                zoomCtx.clearRect(0,0, zoomCtx.canvas.width, zoomCtx.canvas.height);
                zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color') || '#7cfc00';
                zoomCtx.textAlign = 'center'; zoomCtx.textBaseline = 'middle';
                const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12)); 
                zoomCtx.font = `bold ${fontSize}px Arial`;
                wrapText(zoomCtx, "Muovi il mouse sull'immagine", zoomCtx.canvas.width / 2, zoomCtx.canvas.height / 2, zoomCtx.canvas.width - 20, fontSize * 1.2);
            }
        }

        function clearFixedMagnifier() {
            if (!fixedZoomCanvas) return; const zoomCtx = fixedZoomCanvas.getContext('2d'); if (!zoomCtx) return;
            zoomCtx.clearRect(0,0, zoomCtx.canvas.width, zoomCtx.canvas.height);
            zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color') || '#7cfc00';
            zoomCtx.textAlign = 'center'; zoomCtx.textBaseline = 'middle';
            const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12)); zoomCtx.font = `bold ${fontSize}px Arial`;
            wrapText(zoomCtx, "Carica un'immagine", fixedZoomCanvas.width / 2, fixedZoomCanvas.height / 2, fixedZoomCanvas.width - 10, fontSize * 1.2);
            p5StyleMagnifier.isInitialized = false;
        }
        
        function getLuminance(r, g, b) { return (r + g + b) / 3; }
        function calculateAverageColor(imageData) { const data = imageData.data; const len = data.length; let rSum = 0, gSum = 0, bSum = 0; let pixelCount = len / 4; if (pixelCount === 0) return { r: 128, g: 128, b: 128 }; for (let i = 0; i < len; i += 4) { rSum += data[i]; gSum += data[i+1]; bSum += data[i+2]; } return { r: Math.round(rSum / pixelCount), g: Math.round(gSum / pixelCount), b: Math.round(bSum / pixelCount) }; }
        function getComplementaryColor(color) { return { r: 255 - color.r, g: 255 - color.g, b: 255 - color.b }; }
        function updateThemeColors(averageColor, complementaryColor) { const rootStyle = document.documentElement.style; const avgColorStr = `rgb(${averageColor.r}, ${averageColor.g}, ${averageColor.b})`; const compColorStr = `rgb(${complementaryColor.r}, ${complementaryColor.g}, ${complementaryColor.b})`; rootStyle.setProperty('--main-bg-color', compColorStr); rootStyle.setProperty('--main-accent-color', avgColorStr); rootStyle.setProperty('--slider-thumb-color', avgColorStr); const compLuminance = getLuminance(complementaryColor.r, complementaryColor.g, complementaryColor.b); const sliderTrackColor = compLuminance > 128 ? '#555555' : '#DDDDDD'; rootStyle.setProperty('--slider-track-color', sliderTrackColor); rootStyle.setProperty('--header-border-color', avgColorStr); rootStyle.setProperty('--button-text-color', avgColorStr); rootStyle.setProperty('--button-border-color', avgColorStr); const bodyTextColor = compLuminance > 128 ? '#000000' : '#f0fff0'; rootStyle.setProperty('--general-text-color', bodyTextColor); const hoverR = Math.max(0, Math.min(255, complementaryColor.r + (compLuminance > 128 ? -30 : 30))); const hoverG = Math.max(0, Math.min(255, complementaryColor.g + (compLuminance > 128 ? -30 : 30))); const hoverB = Math.max(0, Math.min(255, complementaryColor.b + (compLuminance > 128 ? -30 : 30))); rootStyle.setProperty('--button-hover-bg-color', `rgb(${hoverR},${hoverG},${hoverB})`); document.querySelectorAll('p, .image-sub-text, .kernel-matrix-text').forEach(el => { el.style.color = 'var(--paragraph-text-color)';}); }
        function resetThemeColors() { const rootStyle = document.documentElement.style; rootStyle.setProperty('--main-bg-color', '#000000'); rootStyle.setProperty('--main-accent-color', '#7cfc00'); rootStyle.setProperty('--slider-thumb-color', '#7cfc00'); rootStyle.setProperty('--slider-track-color', '#FFFFFF'); rootStyle.setProperty('--header-border-color', '#FFFFFF'); rootStyle.setProperty('--button-text-color', '#FFFFFF'); rootStyle.setProperty('--button-border-color', '#FFFFFF'); rootStyle.setProperty('--button-hover-bg-color', '#333333'); rootStyle.setProperty('--general-text-color', '#f0fff0'); document.querySelectorAll('p, .image-sub-text, .kernel-matrix-text').forEach(el => { el.style.color = ''; }); }
        function convertToGrayscale(sourceCanvasOrImageData) { let imageDataObj; let sourceWidth, sourceHeight; if (!sourceCanvasOrImageData) { console.warn("[DEBUG] convertToGrayscale: Input nullo."); return null; } if (sourceCanvasOrImageData instanceof HTMLCanvasElement) { const ctx = sourceCanvasOrImageData.getContext('2d'); if (!ctx) { console.warn("[DEBUG] convertToGrayscale: Impossibile ottenere context 2D da:", sourceCanvasOrImageData.id); return null; } sourceWidth = sourceCanvasOrImageData.width; sourceHeight = sourceCanvasOrImageData.height; if (sourceWidth === 0 || sourceHeight === 0) { console.warn("[DEBUG] convertToGrayscale: Canvas sorgente con dimensione 0:", sourceCanvasOrImageData.id); return null;} try { imageDataObj = ctx.getImageData(0, 0, sourceWidth, sourceHeight); } catch (e) { console.warn("[DEBUG] Errore getImageData in convertToGrayscale:", e, sourceCanvasOrImageData.id); return null; } } else if (sourceCanvasOrImageData instanceof ImageData) { imageDataObj = sourceCanvasOrImageData; sourceWidth = imageDataObj.width; sourceHeight = imageDataObj.height; if (sourceWidth === 0 || sourceHeight === 0) { console.warn("[DEBUG] convertToGrayscale: ImageData sorgente con dimensione 0."); return null;} } else { console.warn("[DEBUG] convertToGrayscale: Tipo di input non valido."); return null; } if (!imageDataObj) { console.warn("[DEBUG] convertToGrayscale: Impossibile ottenere ImageData finale."); return null; } const data = imageDataObj.data; const newClampedArray = new Uint8ClampedArray(data.length); const newImageData = new ImageData(newClampedArray, sourceWidth, sourceHeight); const newData = newImageData.data; for (let i = 0; i < data.length; i += 4) { const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]; newData[i] = newData[i+1] = newData[i+2] = gray; newData[i+3] = data[i+3]; /* Mantieni alpha originale */ } return newImageData; }
        function getPixelBlockAverageRGB(sourceImageData, startX, startY, blockWidth, blockHeight, imageWidth) { let rSum = 0, gSum = 0, bSum = 0, count = 0; for (let y = startY; y < startY + blockHeight && y < sourceImageData.height; y++) { for (let x = startX; x < startX + blockWidth && x < sourceImageData.width; x++) { const idx = (y * imageWidth + x) * 4; rSum += sourceImageData.data[idx]; gSum += sourceImageData.data[idx + 1]; bSum += sourceImageData.data[idx + 2]; count++; } } if (count === 0) return { r: 0, g: 0, b: 0 }; return { r: Math.round(rSum / count), g: Math.round(gSum / count), b: Math.round(bSum / count) }; }
        function drawNumbersOnCanvas(targetCanvas, sourceImageData, blockSize) { if (!targetCanvas || !sourceImageData) return; const targetCtx = targetCanvas.getContext('2d'); if (!targetCtx) return; targetCanvas.width = sourceImageData.width; targetCanvas.height = sourceImageData.height; targetCtx.fillStyle = document.documentElement.style.getPropertyValue('--main-bg-color') || '#000000'; targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height); const fontSize = Math.max(4, Math.floor(blockSize / 3.9)); targetCtx.font = `${fontSize}px monospace`; targetCtx.textBaseline = 'top'; const avgAccentColor = document.documentElement.style.getPropertyValue('--main-accent-color') || 'rgb(128,255,128)'; const accentRGBMatch = avgAccentColor.match(/\d+/g); if (!accentRGBMatch || accentRGBMatch.length < 3) return; const accentRGB = accentRGBMatch.map(Number); for (let y = 0; y < sourceImageData.height - blockSize / 2; y += blockSize) { for (let x = 0; x < sourceImageData.width - blockSize / 2; x += blockSize) { const avgColor = getPixelBlockAverageRGB(sourceImageData, x, y, blockSize, blockSize, sourceImageData.width); const rStr = avgColor.r.toString().padStart(3, '0'), gStr = avgColor.g.toString().padStart(3, '0'), bStr = avgColor.b.toString().padStart(3, '0'); let textY = y + 1; const textX = x + 1; targetCtx.fillStyle = `rgb(255,80,80)`; targetCtx.fillText(rStr, textX, textY); textY += fontSize * 1.05; targetCtx.fillStyle = `rgb(80,255,80)`; if (textY < y + blockSize - fontSize / 2) targetCtx.fillText(gStr, textX, textY); textY += fontSize * 1.05; targetCtx.fillStyle = `rgb(80,80,255)`; if (textY < y + blockSize - fontSize / 2) targetCtx.fillText(bStr, textX, textY); } } }
        function getAllDemoCanvases() { return [grayscaleCanvas, sobelCanvas, opticalFlowCanvas, loweFeaturesCanvas, loweRecognitionCanvas, objdetectGrayscaleCanvas, objdetectBinaryCanvas, objdetectResultCanvas, segmentationOriginalCanvas, segmentationResultCanvas, cnnInputPatchCanvas, ...featureMapOutputCanvases, ...kernelVizCanvases].filter(Boolean); }
        function animateMatrixTransition(canvas, isToNumeric, sourceOrRenderPayload, callback) { const ctx = canvas.getContext('2d'); if (!ctx || canvas.width === 0 || canvas.height === 0) { if (callback) callback(); return; } const width = canvas.width; const height = canvas.height; const duration = 400; let startTime = null; const charSize = Math.max(8, numericViewBlockSize / 2); ctx.font = `${charSize}px monospace`; const katakana = "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン01"; const accentColor = document.documentElement.style.getPropertyValue('--main-accent-color') || '#3f3'; function step(timestamp) { if (!startTime) startTime = timestamp; const elapsed = timestamp - startTime; const progress = Math.min(elapsed / duration, 1); ctx.fillStyle = `rgba(0, 0, 0, ${isToNumeric ? 0.15 : 0.25})`; ctx.fillRect(0, 0, width, height); ctx.fillStyle = accentColor; const density = isToNumeric ? 30 : 50; for (let i = 0; i < density * (width/100); i++) { if (Math.random() > 0.3) { const x = Math.random() * width; const y = Math.random() * height; const char = katakana[Math.floor(Math.random() * katakana.length)]; ctx.fillText(char, x, y); } } if (progress < 1) { requestAnimationFrame(step); } else { if (callback) callback(); } } requestAnimationFrame(step); }
        function showNumericView() { if (!currentUploadedImage || !currentUploadedImage.complete || currentUploadedImage.naturalWidth === 0 || isNumericViewActive) return; isNumericViewActive = true; if(mainImageSubText) mainImageSubText.textContent = "Dati RGB medi (blocco). Mouse sull'img per dettagli."; if (loweCubeAnimationId) { cancelAnimationFrame(loweCubeAnimationId); loweCubeAnimationId = null; } if (mainDisplayCanvas && currentUploadedImage.naturalWidth > 0) { const mainCtx = mainDisplayCanvas.getContext('2d'); if (mainCtx) { try { const mainImageData = pixelCtx.getImageData(0, 0, pixelCanvas.width, pixelCanvas.height); animateMatrixTransition(mainDisplayCanvas, true, null, () => { drawNumbersOnCanvas(mainDisplayCanvas, mainImageData, numericViewBlockSize); }); } catch(e) { drawCanvasPlaceholder(mainDisplayCanvas, "NUM DATA (err)"); } } } getAllDemoCanvases().forEach(canvas => { if (canvas && getComputedStyle(canvas).display !== 'none' && canvas.width > 0 && canvas.height > 0 && canvas !== mainDisplayCanvas ) { const ctx = canvas.getContext('2d'); if (ctx) { try { const currentDemoImageData = ctx.getImageData(0, 0, canvas.width, canvas.height); animateMatrixTransition(canvas, true, null, () => { drawNumbersOnCanvas(canvas, currentDemoImageData, numericViewBlockSize); }); } catch (e) { drawCanvasPlaceholder(canvas, "NUM DATA (err)"); } } } else if (canvas && canvas.id && canvas !== mainDisplayCanvas ) { drawCanvasPlaceholder(canvas, "NUM DATA"); } }); if (p5StyleMagnifier.isInitialized && p5StyleMagnifier.lastMouseX !== -1 && mainDisplayCanvas) { const mainCanvasRect = mainDisplayCanvas.getBoundingClientRect(); if (mainCanvasRect.width > 0) { const fakeEvent = { clientX: mainCanvasRect.left + (p5StyleMagnifier.lastMouseX / (mainDisplayCanvas.width / mainCanvasRect.width)), clientY: mainCanvasRect.top + (p5StyleMagnifier.lastMouseY / (mainDisplayCanvas.height / mainCanvasRect.height)) }; updateFixedMagnifier(fakeEvent); } } else if (p5StyleMagnifier.isInitialized && fixedZoomCanvas) {  const zoomCtx = fixedZoomCanvas.getContext('2d'); if(zoomCtx) { zoomCtx.clearRect(0,0, zoomCtx.canvas.width, zoomCtx.canvas.height); zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color'); zoomCtx.textAlign = 'center'; const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12)); zoomCtx.font = `bold ${fontSize}px Arial`; wrapText(zoomCtx, "Vista Numerica Attiva", fixedZoomCanvas.width / 2, fixedZoomCanvas.height / 2, fixedZoomCanvas.width - 20, fontSize * 1.2); } } }
        function hideNumericView() { if (!isNumericViewActive) return; isNumericViewActive = false; if(mainImageSubText) mainImageSubText.textContent = "Immagine caricata. Passa il mouse sull'immagine per i dettagli."; if (currentUploadedImage && currentUploadedImage.complete && currentUploadedImage.naturalWidth > 0) { if (mainDisplayCanvas) { animateMatrixTransition(mainDisplayCanvas, false, null, () => { const ctx = mainDisplayCanvas.getContext('2d'); if (ctx) { mainDisplayCanvas.width = currentUploadedImage.naturalWidth; mainDisplayCanvas.height = currentUploadedImage.naturalHeight; ctx.drawImage(currentUploadedImage, 0, 0); } else { drawCanvasPlaceholder(mainDisplayCanvas); } }); } if (demoRenderFlags.sobel) { animateMatrixTransition(grayscaleCanvas, false, null, () => { if(grayscaleImageDataForSobel && grayscaleCanvas.getContext('2d')) grayscaleCanvas.getContext('2d').putImageData(grayscaleImageDataForSobel,0,0);}); animateMatrixTransition(sobelCanvas, false, null, () => { if(grayscaleImageDataForSobel && gradientMagnitudeData && sobelThresholdSlider) applyThresholdAndDrawSobel(parseInt(sobelThresholdSlider.value));}); } if (demoRenderFlags.opticalFlow && opticalFlowCanvas && typeof renderOpticalFlowDemo === 'function') animateMatrixTransition(opticalFlowCanvas, false, null, () => renderOpticalFlowDemo(currentUploadedImage)); if (demoRenderFlags.lowe && loweFeaturesCanvas && loweRecognitionCanvas && typeof renderLoweInspiredDemo === 'function') { animateMatrixTransition(loweFeaturesCanvas, false, null, () => {}); animateMatrixTransition(loweRecognitionCanvas, false, null, () => { if(!gradientMagnitudeData && grayscaleImageDataForSobel && typeof processImageForSobel === 'function') processImageForSobel(currentUploadedImage); renderLoweInspiredDemo(currentUploadedImage); }); } if (demoRenderFlags.blob && objdetectResultCanvas && binaryThresholdSlider && typeof renderBlobDetectionDemo === 'function') { animateMatrixTransition(objdetectResultCanvas, false, null, () => renderBlobDetectionDemo(currentUploadedImage, parseInt(binaryThresholdSlider.value))); if (objdetectGrayscaleCanvas) { animateMatrixTransition(objdetectGrayscaleCanvas, false, null, () => { if (typeof renderBlobDetectionDemo === 'function' && currentUploadedImage && binaryThresholdSlider) { renderBlobDetectionDemo(currentUploadedImage, parseInt(binaryThresholdSlider.value)); } else if (objdetectGrayscaleCanvas.getContext('2d') && currentUploadedImage) { const tempCtx = objdetectGrayscaleCanvas.getContext('2d'); const gsData = convertToGrayscale(currentUploadedImage); if(gsData && currentUploadedImage.naturalWidth > 0) { objdetectGrayscaleCanvas.width = currentUploadedImage.naturalWidth; objdetectGrayscaleCanvas.height = currentUploadedImage.naturalHeight; tempCtx.putImageData(gsData,0,0); } else { drawCanvasPlaceholder(objdetectGrayscaleCanvas); } } }); } if (objdetectBinaryCanvas) { animateMatrixTransition(objdetectBinaryCanvas, false, null, () => { if (typeof renderBlobDetectionDemo === 'function' && currentUploadedImage && binaryThresholdSlider) { renderBlobDetectionDemo(currentUploadedImage, parseInt(binaryThresholdSlider.value)); } else { drawCanvasPlaceholder(objdetectBinaryCanvas); } }); } } if (demoRenderFlags.cnn && cnnInputPatchCanvas && typeof renderCnnFeatureMapsDemo === 'function') { animateMatrixTransition(cnnInputPatchCanvas, false, null, () => { renderCnnFeatureMapsDemo(currentUploadedImage); }); featureMapOutputCanvases.forEach(fmCanvas => { if (fmCanvas) { animateMatrixTransition(fmCanvas, false, null, () => { if (typeof renderCnnFeatureMapsDemo === 'function' && currentUploadedImage) { renderCnnFeatureMapsDemo(currentUploadedImage); } }); } }); kernelVizCanvases.forEach(kvCanvas => { if(kvCanvas) { animateMatrixTransition(kvCanvas, false, null, () => { if (typeof renderCnnFeatureMapsDemo === 'function' && currentUploadedImage) { renderCnnFeatureMapsDemo(currentUploadedImage); } }); } }); } if (p5StyleMagnifier.isInitialized && p5StyleMagnifier.lastMouseX !== -1 && mainDisplayCanvas) { const mainCanvasRect = mainDisplayCanvas.getBoundingClientRect(); if (mainCanvasRect.width > 0) { const fakeEvent = { clientX: mainCanvasRect.left + (p5StyleMagnifier.lastMouseX / (mainDisplayCanvas.width / mainCanvasRect.width)), clientY: mainCanvasRect.top + (p5StyleMagnifier.lastMouseY / (mainDisplayCanvas.height / mainCanvasRect.height)) }; updateFixedMagnifier(fakeEvent); } } else if (p5StyleMagnifier.isInitialized && fixedZoomCanvas) { const zoomCtx = fixedZoomCanvas.getContext('2d'); if(zoomCtx) { zoomCtx.clearRect(0,0, zoomCtx.canvas.width, zoomCtx.canvas.height); zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color'); zoomCtx.textAlign = 'center'; const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12)); zoomCtx.font = `bold ${fontSize}px Arial`; wrapText(zoomCtx, "Muovi il mouse sull'immagine", fixedZoomCanvas.width / 2, fixedZoomCanvas.height / 2, fixedZoomCanvas.width - 20, fontSize * 1.2); } } } else { getAllDemoCanvases().forEach(canvas => {if (canvas !== mainDisplayCanvas) drawCanvasPlaceholder(canvas);}); if (mainDisplayCanvas) drawCanvasPlaceholder(mainDisplayCanvas); } }
        function drawCanvasPlaceholder(canvas, text = 'N/D') { if (!canvas) return; const ctx = canvas.getContext('2d'); if (!ctx) return; let phWidth = 200, phHeight = 150; const cs = canvas.parentElement ? getComputedStyle(canvas.parentElement) : null; const parentClientWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0; const parentPaddingLeft = cs ? parseFloat(cs.paddingLeft) : 0; const parentPaddingRight = cs ? parseFloat(cs.paddingRight) : 0; const availableParentWidth = parentClientWidth - parentPaddingLeft - parentPaddingRight; if (canvas.parentElement && canvas.parentElement.offsetParent && availableParentWidth > 0) { if (canvas.classList.contains('feature-map-output-canvas') || canvas.id === 'cnn-input-patch-canvas' || canvas.classList.contains('kernel-viz-canvas')) { phWidth = canvas.classList.contains('kernel-viz-canvas') ? 60 : Math.max(80, availableParentWidth > 10 ? availableParentWidth -5 : availableParentWidth * 0.9); phHeight = phWidth; } else { phWidth = Math.max(150, availableParentWidth > 20 ? availableParentWidth : availableParentWidth * 0.8); phHeight = phWidth * 0.75; } } else if (canvas.classList.contains('kernel-viz-canvas')) { phWidth = 60; phHeight = 60; } canvas.width = phWidth; canvas.height = phHeight; ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#222'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle = '#555'; ctx.textAlign='center'; ctx.textBaseline = 'middle'; ctx.font = '10px Helvetica'; ctx.fillText(text, canvas.width/2, canvas.height/2); }
        function resetDemoRenderFlags() { demoRenderFlags = { sobel: false, opticalFlow: false, lowe: false, blob: false, cnn: false, segmentation: false }; if (loweCubeAnimationId) { cancelAnimationFrame(loweCubeAnimationId); loweCubeAnimationId = null; } }
        function setupDemoObservers(imageElement) { if (demoObserver) { demoObserver.disconnect(); } const observerOptions = { root: null, rootMargin: '0px 0px 0px 0px', threshold: 0.05 }; const observerCallback = (entries, observerInstance) => { entries.forEach(entry => { if (entry.isIntersecting && !isNumericViewActive) { const demoType = entry.target.dataset.demoType; if (!currentUploadedImage || !currentUploadedImage.complete || currentUploadedImage.naturalWidth === 0) { console.warn("[DEBUG] Observer: Immagine non pronta per demo", demoType); return; } console.log("[DEBUG] Observer: Intersecting", demoType, "Flag:", demoRenderFlags[demoType]); if (demoType === 'sobel' && !demoRenderFlags.sobel) { console.log("[DEBUG] Observer: Tentativo render Sobel"); if (gradientMagnitudeData && sobelCanvas && sobelThresholdSlider && grayscaleImageDataForSobel) { applyThresholdAndDrawSobel(parseInt(sobelThresholdSlider.value)); demoRenderFlags.sobel = true; } else { console.warn("[DEBUG] Observer: Dati mancanti per Sobel"); if(sobelCanvas) drawCanvasPlaceholder(sobelCanvas, "Errore Dati Sobel"); }  } else if (demoType === 'visione-3d' && typeof renderOpticalFlowDemo === 'function' && typeof renderLoweInspiredDemo === 'function') { if (opticalFlowCanvas && !demoRenderFlags.opticalFlow) { renderOpticalFlowDemo(currentUploadedImage); demoRenderFlags.opticalFlow = true; } if (loweFeaturesCanvas && loweRecognitionCanvas && !demoRenderFlags.lowe ) { if (!gradientMagnitudeData && grayscaleImageDataForSobel && typeof processImageForSobel === 'function') processImageForSobel(currentUploadedImage); renderLoweInspiredDemo(currentUploadedImage); demoRenderFlags.lowe = true; } } else if (demoType === 'object-recognition' && !demoRenderFlags.blob && binaryThresholdSlider && typeof renderBlobDetectionDemo === 'function') { console.log("[DEBUG] Observer: Tentativo render Blob Detection"); renderBlobDetectionDemo(currentUploadedImage, parseInt(binaryThresholdSlider.value)); demoRenderFlags.blob = true; } else if (demoType === 'deep-learning' && !demoRenderFlags.cnn && cnnInputPatchCanvas && typeof renderCnnFeatureMapsDemo === 'function') { renderCnnFeatureMapsDemo(currentUploadedImage); demoRenderFlags.cnn = true; } } }); }; demoObserver = new IntersectionObserver(observerCallback, observerOptions); document.querySelectorAll('[data-demo-type]').forEach(section => { if(section) demoObserver.observe(section); }); }
        function showInitialState() { console.log("[DEBUG] showInitialState chiamato"); if(headerTitle) headerTitle.style.display = 'none'; if(siteHeader) siteHeader.classList.remove('with-border'); if(changeImageControls) changeImageControls.style.display = 'none'; if(initialUploadPrompt) initialUploadPrompt.style.display = 'block'; if(mainContentWrapper) mainContentWrapper.style.display = 'none'; if(creditsInfo) creditsInfo.style.display = 'none'; currentUploadedImage = null; grayscaleImageDataForSobel = null; gradientMagnitudeData = null; isNumericViewActive = false; if(uploadedImageNumericOverlay) uploadedImageNumericOverlay.style.display = 'none'; if(mainDisplayCanvas) drawCanvasPlaceholder(mainDisplayCanvas, "Immagine Principale"); if(mainImageSubText) mainImageSubText.textContent = "Nessuna immagine caricata."; getAllDemoCanvases().forEach(canvas => { if (canvas && canvas !== mainDisplayCanvas) drawCanvasPlaceholder(canvas); }); if(segmentationOriginalCanvas) drawCanvasPlaceholder(segmentationOriginalCanvas, "Originale K-Means"); if(segmentationResultCanvas) drawCanvasPlaceholder(segmentationResultCanvas, "Segmentato K-Means"); if(thresholdValueDisplay && sobelThresholdSlider) thresholdValueDisplay.textContent = sobelThresholdSlider.value; if(binaryThresholdValueDisplay && binaryThresholdSlider) binaryThresholdValueDisplay.textContent = binaryThresholdSlider.value; if(kmeansKValueDisplay && kmeansKSlider) kmeansKValueDisplay.textContent = kmeansKSlider.value; resetThemeColors(); clearFixedMagnifier(); if (demoObserver) demoObserver.disconnect(); resetDemoRenderFlags(); }
        function showContentState(imageSrc) { console.log("[DEBUG] showContentState chiamato con", imageSrc.substring(0,50) + "..."); if(!initialUploadPrompt || !mainContentWrapper || !mainDisplayCanvas || !headerTitle || !siteHeader || !changeImageControls || !creditsInfo || !mainImageSubText) { return; } initialUploadPrompt.style.display = 'none'; mainContentWrapper.style.display = 'block'; mainImageSubText.textContent = "Immagine caricata. Passa il mouse sull'immagine per i dettagli."; headerTitle.style.display = 'block'; siteHeader.classList.add('with-border'); changeImageControls.style.display = 'flex'; creditsInfo.style.display = 'block'; resetDemoRenderFlags(); currentUploadedImage = new Image(); currentUploadedImage.onload = () => { console.log("[DEBUG] currentUploadedImage.onload: Immagine caricata", currentUploadedImage.width, "x", currentUploadedImage.height); if (currentUploadedImage.naturalWidth === 0) { showInitialState(); if(initialUploadPrompt) {initialUploadPrompt.style.display = 'block'; initialUploadPrompt.textContent = "Errore: Img non valida.";} return; } if (pixelCanvas && pixelCtx && currentUploadedImage.naturalWidth > 0) { pixelCanvas.width = currentUploadedImage.naturalWidth; pixelCanvas.height = currentUploadedImage.naturalHeight; pixelCtx.drawImage(currentUploadedImage, 0, 0, pixelCanvas.width, pixelCanvas.height); console.log("[DEBUG] pixelCanvas aggiornato");} if (mainDisplayCanvas) { mainDisplayCanvas.width = currentUploadedImage.naturalWidth; mainDisplayCanvas.height = currentUploadedImage.naturalHeight; const mainCtx = mainDisplayCanvas.getContext('2d'); if (mainCtx) { mainCtx.drawImage(currentUploadedImage, 0, 0); try { const imageDataForColorAnalysis = mainCtx.getImageData(0, 0, mainDisplayCanvas.width, mainDisplayCanvas.height); const avgColor = calculateAverageColor(imageDataForColorAnalysis); const compColor = getComplementaryColor(avgColor); updateThemeColors(avgColor, compColor); } catch (e) { resetThemeColors(); } } } setupFixedMagnifier(); if (grayscaleCanvas && sobelCanvas && typeof processImageForSobel === 'function') { console.log("[DEBUG] Chiamata processImageForSobel da onload"); processImageForSobel(currentUploadedImage); } if (typeof setupDemoObservers === 'function') { console.log("[DEBUG] Chiamata setupDemoObservers da onload"); setupDemoObservers(currentUploadedImage); } setTimeout(() => { console.log("[DEBUG] Esecuzione rendering forzato demo visibili (timeout)"); document.querySelectorAll('[data-demo-type]').forEach(section => { const rect = section.getBoundingClientRect(); const isVisible = (rect.top < window.innerHeight && rect.bottom >= 0); if (isVisible && !isNumericViewActive) { const demoType = section.dataset.demoType; if (!demoRenderFlags[demoType] || (demoType === 'object-recognition' && !demoRenderFlags.blob) ) { console.log("[DEBUG] Forcing render for initially visible demo (timeout):", demoType); if (demoType === 'object-recognition' && typeof renderBlobDetectionDemo === 'function' && binaryThresholdSlider) { renderBlobDetectionDemo(currentUploadedImage, parseInt(binaryThresholdSlider.value)); } else if (demoType === 'visione-3d' && typeof renderOpticalFlowDemo === 'function' && typeof renderLoweInspiredDemo === 'function') { if (opticalFlowCanvas && !demoRenderFlags.opticalFlow) { renderOpticalFlowDemo(currentUploadedImage); } if (loweFeaturesCanvas && loweRecognitionCanvas && !demoRenderFlags.lowe) { if (!gradientMagnitudeData && grayscaleImageDataForSobel && typeof processImageForSobel === 'function') processImageForSobel(currentUploadedImage); renderLoweInspiredDemo(currentUploadedImage); } } else if (demoType === 'deep-learning' && typeof renderCnnFeatureMapsDemo === 'function' && cnnInputPatchCanvas) { renderCnnFeatureMapsDemo(currentUploadedImage); } /* Non forzare Sobel qui, è già chiamato. K-Means è su bottone. */ } } });}, 350); }; currentUploadedImage.onerror = () => { showInitialState(); if(initialUploadPrompt) { initialUploadPrompt.style.display = 'block'; initialUploadPrompt.textContent = "Errore caricamento img.";} }; currentUploadedImage.src = imageSrc; }
        
        function processImageForSobel(imageElement){ console.log("[DEBUG] processImageForSobel INIZIO"); if(!grayscaleCanvas||!imageElement||!imageElement.naturalWidth||imageElement.naturalWidth===0){ drawCanvasPlaceholder(grayscaleCanvas, "Errore Dati Grayscale"); if(sobelCanvas) drawCanvasPlaceholder(sobelCanvas, "Errore Dati Sobel"); console.warn("[DEBUG] processImageForSobel: prerequisiti mancanti."); return;} grayscaleCanvas.width=imageElement.naturalWidth;grayscaleCanvas.height=imageElement.naturalHeight;const ctxGrayscale=grayscaleCanvas.getContext("2d");if(!ctxGrayscale){ console.warn("[DEBUG] processImageForSobel: Ctx grayscaleCanvas nullo."); return;} ctxGrayscale.drawImage(imageElement,0,0,imageElement.naturalWidth,imageElement.naturalHeight); console.log("[DEBUG] processImageForSobel: Immagine disegnata su grayscaleCanvas"); try{const tempImageData=ctxGrayscale.getImageData(0,0,grayscaleCanvas.width,grayscaleCanvas.height); grayscaleImageDataForSobel=convertToGrayscale(tempImageData); if(grayscaleImageDataForSobel){ ctxGrayscale.putImageData(grayscaleImageDataForSobel,0,0); console.log("[DEBUG] processImageForSobel: Grayscale convertita e disegnata."); applySobel(grayscaleImageDataForSobel); if (gradientMagnitudeData && sobelThresholdSlider && sobelCanvas) { applyThresholdAndDrawSobel(parseInt(sobelThresholdSlider.value)); console.log("[DEBUG] processImageForSobel: Sobel applicato e disegnato."); demoRenderFlags.sobel = true; } else { console.warn("[DEBUG] processImageForSobel: Dati gradiente o slider mancanti per Sobel."); if(sobelCanvas) drawCanvasPlaceholder(sobelCanvas, "Errore Gradiente Sobel"); } } else { console.warn("[DEBUG] processImageForSobel: Conversione grayscale fallita."); drawCanvasPlaceholder(grayscaleCanvas, "Errore Conversione Grayscale"); if(sobelCanvas) drawCanvasPlaceholder(sobelCanvas, "Errore Conversione Grayscale");} }catch(e){console.error("Errore in processImageForSobel:",e);drawCanvasPlaceholder(grayscaleCanvas,"Errore Proc. Sobel"); if(sobelCanvas) drawCanvasPlaceholder(sobelCanvas, "Errore Proc. Sobel");}}
        function applySobel(gsImageData){ if(!gsImageData){ console.warn("[DEBUG] applySobel: gsImageData nullo."); return; } console.log("[DEBUG] applySobel INIZIO"); const width=gsImageData.width,height=gsImageData.height,data=gsImageData.data;gradientMagnitudeData=new Float32Array(width*height);let maxGradient=0;const Gx=[[-1,0,1],[-2,0,2],[-1,0,1]],Gy=[[-1,-2,-1],[0,0,0],[1,2,1]];for(let y=1;y<height-1;y++)for(let x=1;x<width-1;x++){let sumGx=0,sumGy=0;for(let ky=-1;ky<=1;ky++)for(let kx=-1;kx<=1;kx++){const pixel_idx=((y+ky)*width+(x+kx))*4,gray_val=data[pixel_idx];sumGx+=gray_val*Gx[ky+1][kx+1];sumGy+=gray_val*Gy[ky+1][kx+1]}const magnitude=Math.sqrt(sumGx**2+sumGy**2);gradientMagnitudeData[y*width+x]=magnitude;if(magnitude>maxGradient)maxGradient=magnitude}if(maxGradient>0)for(let i=0;i<gradientMagnitudeData.length;i++)gradientMagnitudeData[i]=gradientMagnitudeData[i]/maxGradient*255; else { gradientMagnitudeData.fill(0);} console.log("[DEBUG] applySobel FINE, maxGradient:", maxGradient);}
        function applyThresholdAndDrawSobel(threshold){ if(!gradientMagnitudeData||!sobelCanvas||!grayscaleImageDataForSobel){ console.warn("[DEBUG] applyThresholdAndDrawSobel: Dati mancanti"); if(sobelCanvas)drawCanvasPlaceholder(sobelCanvas,"Errore Dati Sobel"); return;} console.log("[DEBUG] applyThresholdAndDrawSobel INIZIO, soglia:", threshold); const width=grayscaleImageDataForSobel.width,height=grayscaleImageDataForSobel.height;sobelCanvas.width=width;sobelCanvas.height=height;const ctxSobel=sobelCanvas.getContext("2d");if(!ctxSobel){ console.warn("[DEBUG] applyThresholdAndDrawSobel: Ctx Sobel nullo"); return;}const outputImageData=ctxSobel.createImageData(width,height),outputData=outputImageData.data;for(let y=0;y<height;y++)for(let x=0;x<width;x++){const i=y*width+x,magnitude=gradientMagnitudeData[i]||0,edgeColor=magnitude>threshold?255:0,pixelIndex=i*4;outputData[pixelIndex]=outputData[pixelIndex+1]=outputData[pixelIndex+2]=edgeColor;outputData[pixelIndex+3]=255}ctxSobel.putImageData(outputImageData,0,0); console.log("[DEBUG] applyThresholdAndDrawSobel FINE");}
        function renderBlobDetectionDemo(sourceImageElement, binaryThreshold) { console.log("[DEBUG] renderBlobDetectionDemo INIZIO, soglia:", binaryThreshold); if (!objdetectGrayscaleCanvas || !objdetectBinaryCanvas || !objdetectResultCanvas || !sourceImageElement || !sourceImageElement.complete || sourceImageElement.naturalWidth === 0) { drawCanvasPlaceholder(objdetectGrayscaleCanvas, "Grayscale"); drawCanvasPlaceholder(objdetectBinaryCanvas, "Binaria"); drawCanvasPlaceholder(objdetectResultCanvas, "Blob"); console.warn("[DEBUG] renderBlobDetectionDemo: prerequisiti mancanti."); return; } const canvasWidth = sourceImageElement.naturalWidth; const canvasHeight = sourceImageElement.naturalHeight; [objdetectGrayscaleCanvas, objdetectBinaryCanvas, objdetectResultCanvas].forEach(c => { if (c) { c.width = canvasWidth; c.height = canvasHeight; } }); const ctxGrayscale = objdetectGrayscaleCanvas.getContext("2d"); const ctxBinary = objdetectBinaryCanvas.getContext("2d"); const ctxResult = objdetectResultCanvas.getContext("2d"); if (!ctxGrayscale || !ctxBinary || !ctxResult) { console.warn("[DEBUG] renderBlobDetectionDemo: uno o più context sono nulli."); return; } ctxResult.drawImage(sourceImageElement, 0, 0, canvasWidth, canvasHeight); const tempCanvasForGrayscale = document.createElement("canvas"); tempCanvasForGrayscale.width = canvasWidth; tempCanvasForGrayscale.height = canvasHeight; const tempCtxGs = tempCanvasForGrayscale.getContext("2d"); if (!tempCtxGs) return; tempCtxGs.drawImage(sourceImageElement, 0, 0, canvasWidth, canvasHeight); const gsImageData = convertToGrayscale(tempCanvasForGrayscale); if (!gsImageData) { drawCanvasPlaceholder(objdetectGrayscaleCanvas, "Errore Grayscale"); console.warn("[DEBUG] renderBlobDetectionDemo: conversione grayscale fallita."); return; } ctxGrayscale.putImageData(gsImageData, 0, 0); console.log("[DEBUG] renderBlobDetectionDemo: Grayscale disegnato."); const binaryImageData = ctxBinary.createImageData(canvasWidth, canvasHeight); const binaryMap = new Uint8Array(canvasWidth * canvasHeight); for (let i = 0; i < gsImageData.data.length; i += 4) { const isForeground = gsImageData.data[i] > binaryThreshold; const val = isForeground ? 255 : 0; binaryImageData.data[i] = binaryImageData.data[i + 1] = binaryImageData.data[i + 2] = val; binaryImageData.data[i + 3] = 255; binaryMap[i / 4] = isForeground ? 1 : 0; } ctxBinary.putImageData(binaryImageData, 0, 0); console.log("[DEBUG] renderBlobDetectionDemo: Immagine binarizzata disegnata."); const visited = new Uint8Array(canvasWidth * canvasHeight); const minBlobPixelCount = 0.003 * canvasWidth * canvasHeight; ctxResult.strokeStyle = 'rgb(0, 255, 0)'; ctxResult.lineWidth = 3; for (let y = 0; y < canvasHeight; y++) { for (let x = 0; x < canvasWidth; x++) { const currentIdx = y * canvasWidth + x; if (binaryMap[currentIdx] === 1 && !visited[currentIdx]) { const q = [[x, y]]; visited[currentIdx] = 1; let pixelCount = 0; let minX = x, maxX = x, minY = y, maxY = y; while (q.length > 0) { const [cx, cy] = q.shift(); pixelCount++; minX = Math.min(minX, cx); maxX = Math.max(maxX, cx); minY = Math.min(minY, cy); maxY = Math.max(maxY, cy); const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]; for (const [dx, dy] of neighbors) { const nx = cx + dx, ny = cy + dy; const nIdx = ny * canvasWidth + nx; if (nx >= 0 && nx < canvasWidth && ny >= 0 && ny < canvasHeight && binaryMap[nIdx] === 1 && !visited[nIdx]) { visited[nIdx] = 1; q.push([nx, ny]); } } } if (pixelCount > minBlobPixelCount) { ctxResult.strokeRect(minX, minY, maxX - minX + 1, maxY - minY + 1); } } } } console.log("[DEBUG] renderBlobDetectionDemo FINE.");}
        function renderOpticalFlowDemo(sourceImageElement) { if(opticalFlowCanvas && sourceImageElement && sourceImageElement.complete && sourceImageElement.naturalWidth > 0) { opticalFlowCanvas.width = sourceImageElement.naturalWidth > 300 ? sourceImageElement.naturalWidth / 2 : sourceImageElement.naturalWidth; opticalFlowCanvas.height = sourceImageElement.naturalHeight > 300 ? sourceImageElement.naturalHeight / 2 : sourceImageElement.naturalHeight; const ctx = opticalFlowCanvas.getContext('2d'); if(ctx) {ctx.drawImage(sourceImageElement, 0, 0, opticalFlowCanvas.width, opticalFlowCanvas.height); ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0,0,opticalFlowCanvas.width, opticalFlowCanvas.height); ctx.fillStyle="white"; ctx.font = "14px Arial"; ctx.textAlign="center"; ctx.fillText("Optical Flow Demo Placeholder", opticalFlowCanvas.width/2, opticalFlowCanvas.height/2);}} else if(opticalFlowCanvas) drawCanvasPlaceholder(opticalFlowCanvas, "Flusso Ottico");}
        function renderLoweInspiredDemo(sourceImageElement) { if(loweFeaturesCanvas && sourceImageElement && sourceImageElement.complete && sourceImageElement.naturalWidth > 0) { loweFeaturesCanvas.width = sourceImageElement.naturalWidth > 300 ? sourceImageElement.naturalWidth / 2 : sourceImageElement.naturalWidth; loweFeaturesCanvas.height = sourceImageElement.naturalHeight > 300 ? sourceImageElement.naturalHeight / 2 : sourceImageElement.naturalHeight; const ctxF = loweFeaturesCanvas.getContext('2d'); if(ctxF) {ctxF.drawImage(sourceImageElement, 0, 0, loweFeaturesCanvas.width, loweFeaturesCanvas.height); ctxF.fillStyle="white"; ctxF.textAlign="center"; ctxF.font="14px Arial"; ctxF.fillText("Lowe Features Placeholder", loweFeaturesCanvas.width/2, loweFeaturesCanvas.height/2);}} else if(loweFeaturesCanvas) drawCanvasPlaceholder(loweFeaturesCanvas, "Lowe Features"); if(loweRecognitionCanvas && sourceImageElement && sourceImageElement.complete && sourceImageElement.naturalWidth > 0) { loweRecognitionCanvas.width = sourceImageElement.naturalWidth > 300 ? sourceImageElement.naturalWidth/2 : sourceImageElement.naturalWidth; loweRecognitionCanvas.height = sourceImageElement.naturalHeight > 300 ? sourceImageElement.naturalHeight/2 : sourceImageElement.naturalHeight; const ctxR = loweRecognitionCanvas.getContext('2d'); if(ctxR) {ctxR.drawImage(sourceImageElement, 0,0, loweRecognitionCanvas.width, loweRecognitionCanvas.height); ctxR.fillStyle="white";ctxR.textAlign="center"; ctxR.font="14px Arial"; ctxR.fillText("Lowe Recognition Placeholder", loweRecognitionCanvas.width/2, loweRecognitionCanvas.height/2);}} else if(loweRecognitionCanvas) drawCanvasPlaceholder(loweRecognitionCanvas, "Lowe Reco.");}
        function renderCnnFeatureMapsDemo(sourceImageElement) { if(cnnInputPatchCanvas && sourceImageElement && sourceImageElement.complete && sourceImageElement.naturalWidth > 0) { const patchSize = 128; cnnInputPatchCanvas.width=patchSize; cnnInputPatchCanvas.height=patchSize; const ctx = cnnInputPatchCanvas.getContext('2d'); if(ctx) {const sx = Math.max(0, (sourceImageElement.naturalWidth - patchSize) / 2); const sy = Math.max(0, (sourceImageElement.naturalHeight - patchSize) / 2); const sWidth = Math.min(patchSize, sourceImageElement.naturalWidth - sx); const sHeight = Math.min(patchSize, sourceImageElement.naturalHeight - sy); ctx.drawImage(sourceImageElement, sx, sy, sWidth, sHeight, 0,0,patchSize,patchSize); ctx.fillStyle="white"; ctx.textAlign="center"; ctx.font="14px Arial"; ctx.fillText("CNN Input Placeholder", patchSize/2, patchSize/2);}} else if(cnnInputPatchCanvas) drawCanvasPlaceholder(cnnInputPatchCanvas, "CNN Input"); featureMapOutputCanvases.forEach(c => {if(c) drawCanvasPlaceholder(c);}); kernelVizCanvases.forEach(c=>{if(c)drawCanvasPlaceholder(c);});}
        function colorDistance(color1, color2) { const dr = color1[0] - color2[0]; const dg = color1[1] - color2[1]; const db = color1[2] - color2[2]; return Math.sqrt(dr * dr + dg * dg + db * db); }
        function renderKMeansSegmentation(sourceImageElement, k) { if (!segmentationOriginalCanvas || !segmentationResultCanvas || !sourceImageElement || !sourceImageElement.complete || sourceImageElement.naturalWidth === 0) { if(segmentationOriginalCanvas) drawCanvasPlaceholder(segmentationOriginalCanvas, "Originale K-Means"); if(segmentationResultCanvas) drawCanvasPlaceholder(segmentationResultCanvas, "Segmentato K-Means"); return; } const imageWidth = sourceImageElement.naturalWidth; const imageHeight = sourceImageElement.naturalHeight; segmentationOriginalCanvas.width = imageWidth; segmentationOriginalCanvas.height = imageHeight; segmentationResultCanvas.width = imageWidth; segmentationResultCanvas.height = imageHeight; const origCtx = segmentationOriginalCanvas.getContext('2d'); const resultCtx = segmentationResultCanvas.getContext('2d'); if (!origCtx || !resultCtx) return; origCtx.drawImage(sourceImageElement, 0, 0, imageWidth, imageHeight); resultCtx.fillStyle = '#222'; resultCtx.fillRect(0,0, imageWidth, imageHeight); resultCtx.fillStyle = 'white'; resultCtx.textAlign = 'center'; resultCtx.font = '16px Arial'; resultCtx.fillText("Processando K-Means (potrebbe richiedere tempo)...", imageWidth/2, imageHeight/2); const imageData = origCtx.getImageData(0, 0, imageWidth, imageHeight); const pixels = imageData.data; if (kmeansWorker) { kmeansWorker.terminate(); } const workerCode = `function colorDistance(c1, c2) { let d=0; for(let i=0;i<3;i++) d+=(c1[i]-c2[i])**2; return Math.sqrt(d); } self.onmessage = function(e) { const { pixels, width, height, k_clusters } = e.data; const maxIter=10; let centroids=[], sampledPixels=[]; let pixelArr=[]; for(let i=0;i<pixels.length;i+=4) { pixelArr.push([pixels[i],pixels[i+1],pixels[i+2]]); if(i % Math.max(1, Math.floor(pixels.length/(k_clusters*30))) === 0) sampledPixels.push([pixels[i],pixels[i+1],pixels[i+2]]); } if(sampledPixels.length < k_clusters) { sampledPixels = []; for(let i=0; i<pixelArr.length; i+=Math.max(1,Math.floor(pixelArr.length/k_clusters))) if(sampledPixels.length < k_clusters) sampledPixels.push(pixelArr[i]); } centroids = sampledPixels.slice(0, k_clusters); while(centroids.length < k_clusters && centroids.length > 0) centroids.push([...centroids[0]]); if(centroids.length === 0 && k_clusters > 0) centroids.push([0,0,0]); let assignments=new Array(pixelArr.length); for(let iter=0; iter<maxIter; iter++){ let changed=false; for(let i=0;i<pixelArr.length;i++){ let minDist=Infinity, bestClust=0; for(let j=0;j<k_clusters;j++){ const dist=colorDistance(pixelArr[i],centroids[j]); if(dist<minDist){minDist=dist;bestClust=j;}} if(assignments[i] !== bestClust) changed=true; assignments[i]=bestClust;} let newCentroids=Array(k_clusters).fill(0).map(()=>[0,0,0]); let clustCounts=Array(k_clusters).fill(0); for(let i=0;i<pixelArr.length;i++){ const cIdx=assignments[i]; newCentroids[cIdx][0]+=pixelArr[i][0];newCentroids[cIdx][1]+=pixelArr[i][1];newCentroids[cIdx][2]+=pixelArr[i][2];clustCounts[cIdx]++;} for(let i=0;i<k_clusters;i++){ if(clustCounts[i]>0){ const oldC=[...centroids[i]]; centroids[i]=[Math.round(newCentroids[i][0]/clustCounts[i]),Math.round(newCentroids[i][1]/clustCounts[i]),Math.round(newCentroids[i][2]/clustCounts[i])]; if(colorDistance(oldC,centroids[i]) > 0.5 && !changed) changed=true; } else if (pixelArr.length > 0) { centroids[i]=[...pixelArr[Math.floor(Math.random()*pixelArr.length)]]; changed=true;}} if(!changed && iter > 0) break;} let newPixels=new Uint8ClampedArray(pixels.length); for(let i=0;i<pixelArr.length;i++){ const finalC=centroids[assignments[i]]; newPixels[i*4]=finalC[0];newPixels[i*4+1]=finalC[1];newPixels[i*4+2]=finalC[2];newPixels[i*4+3]=255;} self.postMessage({segmentedPixels:newPixels,width,height});};`; const blob = new Blob([workerCode], { type: 'application/javascript' }); kmeansWorker = new Worker(URL.createObjectURL(blob)); kmeansWorker.postMessage({ pixels: pixels, width: imageWidth, height: imageHeight, k_clusters: k }); kmeansWorker.onmessage = function(e) { const { segmentedPixels, width, height } = e.data; const newImageData = new ImageData(segmentedPixels, width, height); resultCtx.putImageData(newImageData, 0, 0); URL.revokeObjectURL(blob); }; kmeansWorker.onerror = function(error) { console.error('Errore K-Means Worker:', error); resultCtx.fillStyle = 'red'; resultCtx.fillText("Errore K-Means!", imageWidth/2, imageHeight/2 + 20); URL.revokeObjectURL(blob);}; }

        if (kmeansKSlider && kmeansKValueDisplay) { kmeansKSlider.addEventListener('input', function() { kmeansKValueDisplay.textContent = this.value; }); }
        if (runSegmentationButton) { runSegmentationButton.addEventListener('click', function() { if (currentUploadedImage && kmeansKSlider) { renderKMeansSegmentation(currentUploadedImage, parseInt(kmeansKSlider.value)); } else { if(segmentationResultCanvas) drawCanvasPlaceholder(segmentationResultCanvas, "Carica Immagine"); } }); }
        function handleFileLoad(file,triggerInput){ if(file){ const reader=new FileReader; reader.onload=function(e){ if (e.target && e.target.result) { showContentState(e.target.result); } else { if(initialUploadPrompt) { initialUploadPrompt.style.display = 'block'; initialUploadPrompt.textContent = "Errore lettura dati file.";} resetThemeColors(); } const dataTransfer=new DataTransfer;dataTransfer.items.add(file); if(triggerInput===primaryFileInput && secondaryFileInput) secondaryFileInput.files=dataTransfer.files; else if(triggerInput===secondaryFileInput && primaryFileInput) primaryFileInput.files=dataTransfer.files; }; reader.onerror = function(e) { if(initialUploadPrompt) { initialUploadPrompt.style.display = 'block'; initialUploadPrompt.textContent = "Errore lettura file.";} resetThemeColors(); }; reader.readAsDataURL(file); } else { if (mainDisplayCanvas && currentUploadedImage === null) { showInitialState(); } } }
        if (sobelThresholdSlider) { sobelThresholdSlider.addEventListener('input', function() { if(thresholdValueDisplay) thresholdValueDisplay.textContent = this.value; const threshold = parseInt(this.value); if(grayscaleImageDataForSobel && gradientMagnitudeData && demoRenderFlags.sobel && !isNumericViewActive) { applyThresholdAndDrawSobel(threshold); if (currentUploadedImage && demoRenderFlags.lowe && loweFeaturesCanvas && loweRecognitionCanvas && typeof renderLoweInspiredDemo === 'function') { renderLoweInspiredDemo(currentUploadedImage); } } }); }
        if (binaryThresholdSlider) { binaryThresholdSlider.addEventListener('input', function(){ if (binaryThresholdValueDisplay) binaryThresholdValueDisplay.textContent = this.value; if (currentUploadedImage && demoRenderFlags.blob && !isNumericViewActive && typeof renderBlobDetectionDemo === 'function') { renderBlobDetectionDemo(currentUploadedImage, parseInt(this.value)); } }); }
        if(initialUploadPrompt) { initialUploadPrompt.addEventListener('click', () => { if(primaryFileInput) primaryFileInput.click(); }); }
        if(primaryFileInput) { primaryFileInput.addEventListener('change', function() { handleFileLoad(this.files[0], this); }); }
        if(changeImageButton) changeImageButton.addEventListener('click', () => { if(secondaryFileInput) secondaryFileInput.click(); });
        if(secondaryFileInput) secondaryFileInput.addEventListener('change', function() { handleFileLoad(this.files[0], this); });
        if (headerTitle) { headerTitle.addEventListener('click', () => { if (isNumericViewActive) hideNumericView(); else if (currentUploadedImage && currentUploadedImage.complete && currentUploadedImage.naturalWidth > 0) showNumericView(); }); }
        if (mainDisplayCanvas) { mainDisplayCanvas.addEventListener('mousemove', updateFixedMagnifier); mainDisplayCanvas.addEventListener('mouseleave', (event) => { if (p5StyleMagnifier.isInitialized && fixedZoomCanvas) { const zoomCtx = fixedZoomCanvas.getContext('2d'); if (!zoomCtx) return; zoomCtx.clearRect(0,0, zoomCtx.canvas.width, zoomCtx.canvas.height); zoomCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--main-accent-color'); zoomCtx.textAlign = 'center'; zoomCtx.textBaseline = 'middle'; const fontSize = Math.max(10, Math.floor(p5StyleMagnifier.zoomBoxSize / 12)); zoomCtx.font = `bold ${fontSize}px Arial`; if (isNumericViewActive) { wrapText(zoomCtx, "Vista Numerica Attiva", zoomCtx.canvas.width / 2, zoomCtx.canvas.height / 2, zoomCtx.canvas.width - 20, fontSize * 1.2); } else { wrapText(zoomCtx, "Muovi il mouse sull'immagine", zoomCtx.canvas.width / 2, zoomCtx.canvas.height / 2, zoomCtx.canvas.width - 20, fontSize * 1.2); } } }); mainDisplayCanvas.addEventListener('mouseenter', (event) => { if (currentUploadedImage && currentUploadedImage.complete && currentUploadedImage.naturalWidth > 0) { updateFixedMagnifier(event); } }); }
        showInitialState();
        console.log("Script principale caricato e inizializzato.");
    </script>
</body>
</html>